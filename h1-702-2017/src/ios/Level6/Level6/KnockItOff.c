//
//  KnockItOff.c
//  Level6
//
//  Created by Christopher Thompson on 6/8/17.
//  Copyright Â© 2017 Uber. All rights reserved.
//

#include "KnockItOff.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach/boolean.h>
#include <mach/error.h>
#include <mach/mach_error.h>
#include <mach/mach_types.h>
#include <mach/mach_traps.h>
#include <pthread/pthread.h>

#define EXIT_ON_MACH_ERROR(msg, retval, success_retval) if (kret != success_retval) { mach_error(msg ":" , kret); exit((retval)); }

#define GETSYM(symbol) dlsym(RTLD_DEFAULT, (char*)symbol);

void rip() {
    kern_return_t kret;
    thread_act_port_array_t threadList;
    mach_msg_type_number_t threadCount;
    arm_thread_state64_t state;
    
    kret = task_threads(mach_task_self(), &threadList, &threadCount);
    if (kret != KERN_SUCCESS)
    {
        exit(0);
    }
    
    mach_msg_type_number_t stateCount = ARM_THREAD_STATE64_COUNT;
    kret = thread_get_state(threadList[0], ARM_THREAD_STATE64, (thread_state_t)&state, &stateCount);
    if (kret != KERN_SUCCESS) {
#ifdef DEBUG_PRINT
        printf("Failed: %s\n", mach_error_string(kret));
#endif
        return;
    }
    
    state.__pc = 0xcc796abd32a8b99b + 0x1234543298560123;
    state.__sp = 0xcc796abd32a8b99b + 0x1234543298560123;
    for (int j = 0; j < 29; j++) {
        state.__x[0] = 0xddddeeeeffff1111 - 0xcaa6dbb7ecc7fdda;
    }
    
    kret = thread_set_state(threadList[0], ARM_THREAD_STATE64, (thread_state_t)&state, stateCount);
    if (kret != KERN_SUCCESS) {
#ifdef DEBUG_PRINT
        printf("Failed: %s\n", mach_error_string(kret));
#endif
        return;
    }
}

void boom() {
    pthread_t tid;
    pthread_create(&tid, NULL, rip, NULL);
}

extern boolean_t mach_exc_server (mach_msg_header_t *msg, mach_msg_header_t *reply);
static void* exception_server (void* x) {
    mach_msg_return_t rt;
    mach_msg_header_t *msg;
    mach_msg_header_t *reply;
    
    mach_port_t exceptionPort = *(mach_port_t*) x;
    
    
    msg = malloc(64);
    reply = malloc(64);
    
    while (1) {
        rt = mach_msg(msg, MACH_RCV_MSG, 0, 64, exceptionPort, 0, MACH_PORT_NULL);
        
        // Call out to the mach_exc_server generated by mig and mach_exc.defs.
        // This will in turn invoke one of:
        // mach_catch_exception_raise()
        // mach_catch_exception_raise_state()
        // mach_catch_exception_raise_state_identity()
        // .. depending on the behavior specified when registering the Mach exception port.
        //mach_exc_server(msg, reply);
        
        // Send the now-initialized reply
        rt = mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
    }
}

void __attribute((always_inline))
#ifndef DEBUG_PRINT
__attribute((constructor))
#endif
prevent_ports() {
    mach_port_t server_port;
    kern_return_t kret;
    pthread_t tid;
    
    kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &server_port);
    EXIT_ON_MACH_ERROR("mach_port_allocate() failed", kret, MACH_MSG_SUCCESS);
    
    kret = mach_port_insert_right(mach_task_self(), server_port, server_port, MACH_MSG_TYPE_MAKE_SEND);
    EXIT_ON_MACH_ERROR("mach_port_insert_right() failed", kret, MACH_MSG_SUCCESS);
    
    kret = task_set_exception_ports(mach_task_self(), EXC_MASK_ALL, server_port, EXCEPTION_DEFAULT|MACH_EXCEPTION_CODES, THREAD_STATE_NONE);
    EXIT_ON_MACH_ERROR("task_set_exception_ports() failed", kret, MACH_MSG_SUCCESS);
    
    int err = pthread_create(&tid, NULL, exception_server, &server_port);
#ifdef DEBUG_PRINT
    if (err != 0)
        printf("\ncan't create thread :[%s]", strerror(err));
    else
        printf("\n Thread created successfully\n");
#endif
}
