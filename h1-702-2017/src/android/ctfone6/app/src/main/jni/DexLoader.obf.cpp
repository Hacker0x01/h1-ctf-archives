// GENERATED STRING OBFUSCATED FILE
// DO NOT EDIT


__attribute__((unused)) static inline char *xor_encrypt(char key, char *string, char *out, int n)
{
    int i;

    if (out != (char *)0 && out[0] != '\x00')
        return out;

    for(i = 0; i < n; i++) {
        out[i] = string[i] ^ key;
    }
    return out;
}
static char dec_str_25[12] __attribute__((unused)) = {'\x00'};
static char enc_str_25[] __attribute__((unused)) = {'\x13', '\x5', '\x3', '\x12', '\x5', '\x14', '\x1', '\x13', '\x13', '\x5', '\x14', 0x0};
static char dec_str_24[47] __attribute__((unused)) = {'\x00'};
static char enc_str_24[] __attribute__((unused)) = {'\x16', '\x72', '\x5f', '\x50', '\x5a', '\x4c', '\x51', '\x57', '\x5a', '\x11', '\x5d', '\x51', '\x50', '\x4a', '\x5b', '\x50', '\x4a', '\x11', '\x7d', '\x51', '\x50', '\x4a', '\x5b', '\x46', '\x4a', '\x5', '\x72', '\x54', '\x5f', '\x48', '\x5f', '\x11', '\x52', '\x5f', '\x50', '\x59', '\x11', '\x6d', '\x4a', '\x4c', '\x57', '\x50', '\x59', '\x5', '\x17', '\x68', 0x0};
static char dec_str_23[13] __attribute__((unused)) = {'\x00'};
static char enc_str_23[] __attribute__((unused)) = {'\x57', '\x55', '\x44', '\x7f', '\x56', '\x56', '\x7d', '\x49', '\x73', '\x51', '\x43', '\x55', 0x0};
static char dec_str_22[40] __attribute__((unused)) = {'\x00'};
static char enc_str_22[] __attribute__((unused)) = {'\x7c', '\x70', '\x72', '\x31', '\x7a', '\x67', '\x7e', '\x72', '\x6f', '\x73', '\x7a', '\x31', '\x6c', '\x70', '\x72', '\x7a', '\x6b', '\x77', '\x76', '\x71', '\x78', '\x31', '\x56', '\x4d', '\x7a', '\x7e', '\x73', '\x73', '\x66', '\x57', '\x7e', '\x69', '\x7a', '\x51', '\x70', '\x56', '\x7b', '\x7a', '\x7e', 0x0};
static char dec_str_21[14] __attribute__((unused)) = {'\x00'};
static char enc_str_21[] __attribute__((unused)) = {'\x32', '\x2e', '\x2c', '\x24', '\x35', '\x29', '\x28', '\x2f', '\x26', '\x6f', '\x2b', '\x20', '\x33', 0x0};
static char dec_str_20[7] __attribute__((unused)) = {'\x00'};
static char enc_str_20[] __attribute__((unused)) = {'\x3f', '\x25', '\x24', '\x34', '\x35', '\x28', 0x0};
static char dec_str_19[4] __attribute__((unused)) = {'\x00'};
static char enc_str_19[] __attribute__((unused)) = {'\x3b', '\x3a', '\x27', 0x0};
static char dec_str_18[21] __attribute__((unused)) = {'\x00'};
static char enc_str_18[] __attribute__((unused)) = {'\x3', '\x2', '\x67', '\x41', '\x4a', '\x5d', '\x4a', '\x4', '\x47', '\x4a', '\x45', '\x4c', '\x4', '\x64', '\x49', '\x41', '\x4e', '\x48', '\x5f', '\x10', 0x0};
static char dec_str_17[12] __attribute__((unused)) = {'\x00'};
static char enc_str_17[] __attribute__((unused)) = {'\x32', '\x39', '\x2b', '\x15', '\x32', '\x2f', '\x28', '\x3d', '\x32', '\x3f', '\x39', 0x0};
static char dec_str_16[38] __attribute__((unused)) = {'\x00'};
static char enc_str_16[] __attribute__((unused)) = {'\x36', '\x52', '\x74', '\x7f', '\x68', '\x7f', '\x31', '\x72', '\x7f', '\x70', '\x79', '\x31', '\x4d', '\x6a', '\x6c', '\x77', '\x70', '\x79', '\x25', '\x37', '\x52', '\x74', '\x7f', '\x68', '\x7f', '\x31', '\x72', '\x7f', '\x70', '\x79', '\x31', '\x5d', '\x72', '\x7f', '\x6d', '\x6d', '\x25', 0x0};
static char dec_str_15[10] __attribute__((unused)) = {'\x00'};
static char enc_str_15[] __attribute__((unused)) = {'\x23', '\x20', '\x2e', '\x2b', '\xc', '\x23', '\x2e', '\x3c', '\x3c', 0x0};
static char dec_str_14[26] __attribute__((unused)) = {'\x00'};
static char enc_str_14[] __attribute__((unused)) = {'\x6e', '\x6f', '\xa', '\x2c', '\x27', '\x30', '\x27', '\x69', '\x2a', '\x27', '\x28', '\x21', '\x69', '\x5', '\x2a', '\x27', '\x35', '\x35', '\xa', '\x29', '\x27', '\x22', '\x23', '\x34', '\x7d', 0x0};
static char dec_str_13[15] __attribute__((unused)) = {'\x00'};
static char enc_str_13[] __attribute__((unused)) = {'\x2e', '\x2c', '\x3d', '\xa', '\x25', '\x28', '\x3a', '\x3a', '\x5', '\x26', '\x28', '\x2d', '\x2c', '\x3b', 0x0};
static char dec_str_12[21] __attribute__((unused)) = {'\x00'};
static char enc_str_12[] __attribute__((unused)) = {'\x76', '\x77', '\x12', '\x34', '\x3f', '\x28', '\x3f', '\x71', '\x32', '\x3f', '\x30', '\x39', '\x71', '\xd', '\x2a', '\x2c', '\x37', '\x30', '\x39', '\x65', 0x0};
static char dec_str_11[16] __attribute__((unused)) = {'\x00'};
static char enc_str_11[] __attribute__((unused)) = {'\x26', '\x24', '\x35', '\x0', '\x23', '\x32', '\x2e', '\x2d', '\x34', '\x35', '\x24', '\x11', '\x20', '\x35', '\x29', 0x0};
static char dec_str_10[36] __attribute__((unused)) = {'\x00'};
static char enc_str_10[] __attribute__((unused)) = {'\x0', '\x64', '\x42', '\x49', '\x5e', '\x49', '\x7', '\x44', '\x49', '\x46', '\x4f', '\x7', '\x7b', '\x5c', '\x5a', '\x41', '\x46', '\x4f', '\x13', '\x61', '\x1', '\x64', '\x42', '\x49', '\x5e', '\x49', '\x7', '\x41', '\x47', '\x7', '\x6e', '\x41', '\x44', '\x4d', '\x13', 0x0};
static char dec_str_9[7] __attribute__((unused)) = {'\x00'};
static char enc_str_9[] __attribute__((unused)) = {'\x33', '\x31', '\x20', '\x10', '\x3d', '\x26', 0x0};
static char dec_str_8[81] __attribute__((unused)) = {'\x00'};
static char enc_str_8[] __attribute__((unused)) = {'\x2', '\x66', '\x40', '\x4b', '\x5c', '\x4b', '\x5', '\x46', '\x4b', '\x44', '\x4d', '\x5', '\x79', '\x5e', '\x58', '\x43', '\x44', '\x4d', '\x11', '\x66', '\x40', '\x4b', '\x5c', '\x4b', '\x5', '\x46', '\x4b', '\x44', '\x4d', '\x5', '\x79', '\x5e', '\x58', '\x43', '\x44', '\x4d', '\x11', '\x66', '\x40', '\x4b', '\x5c', '\x4b', '\x5', '\x46', '\x4b', '\x44', '\x4d', '\x5', '\x79', '\x5e', '\x58', '\x43', '\x44', '\x4d', '\x11', '\x66', '\x40', '\x4b', '\x5c', '\x4b', '\x5', '\x46', '\x4b', '\x44', '\x4d', '\x5', '\x69', '\x46', '\x4b', '\x59', '\x59', '\x66', '\x45', '\x4b', '\x4e', '\x4f', '\x58', '\x11', '\x3', '\x7c', 0x0};
static char dec_str_7[7] __attribute__((unused)) = {'\x00'};
static char enc_str_7[] __attribute__((unused)) = {'\x19', '\x4c', '\x4b', '\x4c', '\x51', '\x1b', 0x0};
static char dec_str_6[36] __attribute__((unused)) = {'\x00'};
static char enc_str_6[] __attribute__((unused)) = {'\x9', '\x6d', '\x4b', '\x40', '\x57', '\x40', '\xe', '\x48', '\x4e', '\xe', '\x67', '\x48', '\x4d', '\x44', '\x1a', '\x6d', '\x4b', '\x40', '\x57', '\x40', '\xe', '\x4d', '\x40', '\x4f', '\x46', '\xe', '\x72', '\x55', '\x53', '\x48', '\x4f', '\x46', '\x1a', '\x8', '\x77', 0x0};
static char dec_str_5[7] __attribute__((unused)) = {'\x00'};
static char enc_str_5[] __attribute__((unused)) = {'\x74', '\x21', '\x26', '\x21', '\x3c', '\x76', 0x0};
static char dec_str_4[16] __attribute__((unused)) = {'\x00'};
static char enc_str_4[] __attribute__((unused)) = {'\x5e', '\x55', '\x42', '\x55', '\x1b', '\x58', '\x55', '\x5a', '\x53', '\x1b', '\x77', '\x58', '\x55', '\x47', '\x47', 0x0};
static char dec_str_3[13] __attribute__((unused)) = {'\x00'};
static char enc_str_3[] __attribute__((unused)) = {'\x47', '\x4c', '\x5b', '\x4c', '\x2', '\x44', '\x42', '\x2', '\x6b', '\x44', '\x41', '\x48', 0x0};
static char dec_str_2[29] __attribute__((unused)) = {'\x00'};
static char enc_str_2[] __attribute__((unused)) = {'\x4b', '\x4e', '\x43', '\x59', '\x46', '\x44', '\x0', '\x5c', '\x56', '\x5c', '\x5b', '\x4a', '\x42', '\x0', '\x6b', '\x4a', '\x57', '\x6c', '\x43', '\x4e', '\x5c', '\x5c', '\x63', '\x40', '\x4e', '\x4b', '\x4a', '\x5d', 0x0};
static char dec_str_1[30] __attribute__((unused)) = {'\x00'};
static char enc_str_1[] __attribute__((unused)) = {'\x67', '\x62', '\x6c', '\x6e', '\x76', '\xb', '\x59', '\x4a', '\x4c', '\xc', '\x72', '\x7c', '\x6f', '\x68', '\x9', '\xa', '\x72', '\x5c', '\x4f', '\x48', '\x79', '\x5c', '\x5a', '\x6b', '\x4c', '\x59', '\x4c', '\x5d', '\x7d', 0x0};
static char dec_str_0[10] __attribute__((unused)) = {'\x00'};
static char enc_str_0[] __attribute__((unused)) = {'\x27', '\x22', '\x29', '\x2a', '\x39', '\x3f', '\x65', '\x38', '\x24', 0x0};
//
// Created by Christopher Thompson on 6/28/17.
//

#include "DexLoader.h"
#include <jni.h>
#include <vector>
#include "android/log.h"

#include <jni.h>
#include <string>
#include <dlfcn.h>
#include <sys/mman.h>
#include <unistd.h>

#define  LOG_TAG    "DexLoader"
//#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
//#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGI(...)
#define LOGE(...)

#define log(FMT, ...) __android_log_print(ANDROID_LOG_VERBOSE, "JDWPFun", FMT, ##__VA_ARGS__)

// Vtable structure. Just to make messing around with it more intuitive

void anti_debug();

struct VT_JdwpAdbState {
    unsigned long x;
    unsigned long y;
    void * JdwpSocketState_destructor;
    void * _JdwpSocketState_destructor;
    void * Accept;
    void * showmanyc;
    void * ShutDown;
    void * ProcessIncoming;
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
    void* lib = dlopen(xor_encrypt(75, enc_str_0, dec_str_0, 9), RTLD_NOW);
    if (lib == NULL) {
        dlerror();
    } else {

        struct VT_JdwpAdbState *vtable = ( struct VT_JdwpAdbState *)dlsym(lib, xor_encrypt(56, enc_str_1, dec_str_1, 29));

        if (vtable == 0) {
        } else {

            unsigned long pagesize = sysconf(_SC_PAGESIZE);
            unsigned long page = (unsigned long)vtable & ~(pagesize-1);

            mprotect((void *)page, pagesize, PROT_READ | PROT_WRITE);
            vtable->ProcessIncoming = vtable->ShutDown;
            mprotect((void *)page, pagesize, PROT_READ);
        }
    }
    return  JNI_VERSION_1_6;
}


#define STRINGIFY(x) #x
#define CLEANUP for (size_t i = 0; i < localRefs.size(); i++) { \
                        env->DeleteLocalRef(localRefs[i]); \
                }
#define CHECK_JNI_ERR(x) \
        if (x == NULL) { \
            LOGE("Unable to find: %s", STRINGIFY(x)); \
            CLEANUP \
            return; \
        } \
        if ((exc = env->ExceptionOccurred())) { \
            env->ExceptionDescribe(); \
            env->ExceptionClear(); \
            LOGE("Error when trying to resolve: %s", STRINGIFY(x)); \
            return; \
        }

extern "C" {
JNIEXPORT void JNICALL
Java_com_example_asdf_MainActivity_doSomethingCool(JNIEnv *env, jobject context) {
    jthrowable exc;
    std::vector<jobject> localRefs;
    // Finding classes
    jclass contextClass = env->GetObjectClass(context);
    CHECK_JNI_ERR(contextClass);
    jclass dexClassLoaderClass = env->FindClass(xor_encrypt(47, enc_str_2, dec_str_2, 28));
    CHECK_JNI_ERR(dexClassLoaderClass);
    jclass fileClass = env->FindClass(xor_encrypt(45, enc_str_3, dec_str_3, 12));
    CHECK_JNI_ERR(fileClass);
    jclass classClass = env->FindClass(xor_encrypt(52, enc_str_4, dec_str_4, 15));
    CHECK_JNI_ERR(classClass);

    // Finding methods
    jmethodID fileConstructor = env->GetMethodID(fileClass, xor_encrypt(72, enc_str_5, dec_str_5, 6),
                                                 xor_encrypt(33, enc_str_6, dec_str_6, 35));
    CHECK_JNI_ERR(fileConstructor);
    jmethodID dexClassLoaderConstructor = env->GetMethodID(dexClassLoaderClass, xor_encrypt(37, enc_str_7, dec_str_7, 6),
                                                           xor_encrypt(42, enc_str_8, dec_str_8, 80));
    CHECK_JNI_ERR(dexClassLoaderConstructor);

    jmethodID getDirMethod = env->GetMethodID(contextClass, xor_encrypt(84, enc_str_9, dec_str_9, 6),
                                              xor_encrypt(40, enc_str_10, dec_str_10, 35));
    CHECK_JNI_ERR(getDirMethod);
    jmethodID getAbsolutePathMethod = env->GetMethodID(fileClass, xor_encrypt(65, enc_str_11, dec_str_11, 15),
                                                       xor_encrypt(94, enc_str_12, dec_str_12, 20));
    CHECK_JNI_ERR(getAbsolutePathMethod);
    jmethodID getClassLoaderMethod = env->GetMethodID(contextClass, xor_encrypt(73, enc_str_13, dec_str_13, 14),
                                                      xor_encrypt(70, enc_str_14, dec_str_14, 25));
    CHECK_JNI_ERR(getClassLoaderMethod);

    jmethodID loadClassMethod = env->GetMethodID(dexClassLoaderClass, xor_encrypt(79, enc_str_15, dec_str_15, 9),
                                                 xor_encrypt(30, enc_str_16, dec_str_16, 37));
    CHECK_JNI_ERR(loadClassMethod);

    jmethodID newInstanceMethod = env->GetMethodID(classClass, xor_encrypt(92, enc_str_17, dec_str_17, 11),
                                                   xor_encrypt(43, enc_str_18, dec_str_18, 20));
    CHECK_JNI_ERR(newInstanceMethod);

    // Calling methods
    jstring outDexStr = env->NewStringUTF(xor_encrypt(95, enc_str_19, dec_str_19, 3));
    localRefs.push_back(outDexStr);

    jobject optimizedDexPath = env->CallObjectMethod(context, getDirMethod, outDexStr, 0);
    CHECK_JNI_ERR(optimizedDexPath);

    jstring internalDexPathStr = env->NewStringUTF(xor_encrypt(80, enc_str_20, dec_str_20, 6));
    localRefs.push_back(internalDexPathStr);

    jobject internalDexStoragePath = env->CallObjectMethod(context, getDirMethod, outDexStr, 0);
    CHECK_JNI_ERR(internalDexStoragePath);

    jstring internalDexStr = env->NewStringUTF(xor_encrypt(65, enc_str_21, dec_str_21, 13));
    localRefs.push_back(internalDexStr);

    jobject internalDexPath = env->NewObject(fileClass, fileConstructor, internalDexStoragePath,
                                             internalDexStr);
    localRefs.push_back(internalDexPath);

    jobject internalDexAbsolutePath = env->CallObjectMethod(internalDexPath, getAbsolutePathMethod);
    CHECK_JNI_ERR(internalDexAbsolutePath);
    jobject optimizedDexAbsolutePath = env->CallObjectMethod(optimizedDexPath, getAbsolutePathMethod);
    CHECK_JNI_ERR(optimizedDexAbsolutePath);

    jobject classLoader = env->CallObjectMethod(context, getClassLoaderMethod);
    CHECK_JNI_ERR(classLoader);

    jobject dexClassLoader = env->NewObject(dexClassLoaderClass, dexClassLoaderConstructor,
                                            internalDexAbsolutePath, optimizedDexAbsolutePath, NULL,
                                            classLoader);
    CHECK_JNI_ERR(dexClassLoader);
    localRefs.push_back(dexClassLoader);

    jstring classStr = env->NewStringUTF(xor_encrypt(31, enc_str_22, dec_str_22, 39));
    localRefs.push_back(classStr);

    jobject libraryProviderObject = env->CallObjectMethod(dexClassLoader, loadClassMethod,
                                                          classStr);
    CHECK_JNI_ERR(libraryProviderObject);

    jobject newLibraryProviderObject = env->CallObjectMethod(libraryProviderObject,
                                                             newInstanceMethod);
    CHECK_JNI_ERR(newLibraryProviderObject);

    jclass libraryProviderClass = env->GetObjectClass(newLibraryProviderObject);
    CHECK_JNI_ERR(libraryProviderClass);

    jmethodID getOffMyCaseMethod = env->GetMethodID(libraryProviderClass, xor_encrypt(48, enc_str_23, dec_str_23, 12),
                                                        xor_encrypt(62, enc_str_24, dec_str_24, 46));
    CHECK_JNI_ERR(getOffMyCaseMethod);

    jstring assetStr = env->NewStringUTF(xor_encrypt(96, enc_str_25, dec_str_25, 11));
    localRefs.push_back(assetStr);

    env->CallVoidMethod(newLibraryProviderObject, getOffMyCaseMethod, context, assetStr);

    CLEANUP
}
}

#include <sys/ptrace.h>
#include <sys/wait.h>

static int child_pid;

void *monitor_pid(void *) {
    int status;
    waitpid(child_pid, &status, 0);
    _exit(0);
}

void anti_debug() {
    child_pid = fork();
    if (child_pid == 0) {
        int ppid = getppid();
        int status;

        if (ptrace(PTRACE_ATTACH, ppid, NULL, NULL) == 0) {
            waitpid(ppid, &status, 0);
            ptrace(PTRACE_CONT, ppid, NULL, NULL);
            while (waitpid(ppid, &status, 0)) {
                if (WIFSTOPPED(status)) {
                    ptrace(PTRACE_CONT, ppid, NULL, NULL);
                } else {
                    _exit(0);
                }
            }
        }

    } else {
        pthread_t t;
        pthread_create(&t, NULL, monitor_pid, (void *)NULL);
    }
}
